---
layout  : wiki
title   : java interview
summary : 
date    : 2023-04-30 15:54:10 +0900
updated : 2023-04-30 18:43:44 +0900
tags    : 
toc     : true
public  : false
parent  : [[interview/index]]
latex   : false
---
* TOC
{:toc}

# Java의 특징과 장단점에 대해 설명해주세요.
```
Java의 특징은 크게 3가지로 나눌 수 있습니다. 첫 번째는 객체 지향 프로그래밍(OOP)을 지원한다는 점입니다. 두 번째는 플랫폼 독립성이며, 이는 JVM(Java Virtual Machine)이라는 가상 머신을 이용해 어느 운영체제에서든 Java 프로그램을 실행할 수 있다는 것을 의미합니다. 세 번째는 안정성과 보안성이 높다는 점입니다.

장점으로는 다음과 같은 것들이 있습니다.

- 플랫폼 독립성으로 어느 운영체제에서든 Java 프로그램을 실행할 수 있다.
- 안정성과 보안성이 높아서 오류 발생 확률이 낮고, 보안 문제를 예방할 수 있다.
- JVM이 자동으로 메모리 관리를 해주므로 메모리 누수 등의 문제를 줄일 수 있다.
- 다양한 라이브러리와 프레임워크가 존재하므로 생산성이 높아진다.

단점으로는 다음과 같은 것들이 있습니다.

- C++에 비해 실행 속도가 느리다는 평가가 있습니다.
- JVM에 의존하므로 초기 구동 시간이 길다는 단점이 있다.
- 상대적으로 메모리 사용량이 높아질 수 있다.
```

# Java에서 인터페이스와 추상 클래스의 차이는 무엇인가요?
```
인터페이스와 추상 클래스는 Java에서 추상화(abstraction)를 구현하기 위한 개념입니다. 하지만 인터페이스와 추상 클래스는 목적과 특성이 다릅니다.

인터페이스는 추상 메서드와 상수만을 가진 템플릿입니다. 즉, 인터페이스에서는 메서드의 시그니처만을 정의하고, 구현부는 작성하지 않습니다. 이는 인터페이스를 구현하는 클래스에서 메서드를 직접 구현하도록 강제하기 때문입니다. 또한, 다중 상속을 지원하기 때문에 한 클래스가 여러 개의 인터페이스를 구현할 수 있습니다.

추상 클래스는 일부 메서드는 구현할 수 있고, 일부 메서드는 추상 메서드로 선언할 수 있는 클래스입니다. 추상 메서드는 메서드의 시그니처만을 가지고 있고, 구현부는 작성하지 않습니다. 추상 클래스는 인스턴스화할 수 없기 때문에, 추상 클래스를 상속받아서 추상 메서드를 구현한 서브 클래스를 만들어야 합니다.

추상 클래스와 인터페이스는 모두 추상화를 구현하는 용도로 사용됩니다. 하지만 인터페이스는 구현을 강제하고 다중 상속을 지원하며, 추상 클래스는 일부 메서드를 구현할 수 있고 인스턴스화할 수 없습니다. 따라서 개발자는 인터페이스와 추상 클래스 중에 어떤 것을 사용할지, 어떤 용도로 사용할지를 고려해야 합니다.

인터페이스는 기능의 명세서라고 할 수 있습니다. 즉, 인터페이스는 어떤 객체가 가져야 할 기능(메서드)들을 정의하는 일종의 계약서입니다. 예를 들어, List 인터페이스는 리스트 형태의 데이터를 다루기 위한 메서드들을 정의하고 있습니다. 이를 구현한 ArrayList 클래스나 LinkedList 클래스는 List 인터페이스의 메서드를 반드시 구현해야 합니다. 이러한 인터페이스의 특징으로 인해, 인터페이스는 서로 다른 구현체들을 유연하게 대체할 수 있는 구조를 만들어 줍니다.

추상 클래스는 구현 클래스들이 가져야 할 공통된 기능들을 구현할 수 있도록 하는 용도로 사용됩니다. 즉, 추상 클래스는 구현 클래스들의 공통점을 추출해서 일반화된 형태로 만들어 놓은 것입니다. 예를 들어, Shape 추상 클래스는 도형의 공통 기능을 추상화한 클래스입니다. 이를 구현한 Circle 클래스나 Rectangle 클래스는 Shape 추상 클래스에 정의된 메서드들을 상속받아 사용할 수 있습니다. 이러한 추상 클래스의 특징으로 인해, 추상 클래스는 코드의 재사용성을 높여주고 일관된 구조를 유지할 수 있도록 해줍니다.
```
> [참조: 인파님 티스토리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

# Java에서 예외 처리의 목적은 무엇이며, 어떤 방식으로 처리할 수 있나요?
```
Java에서 예외 처리의 목적은 프로그램 실행 중 발생할 수 있는 예기치 않은 상황(예외)을 처리하여 프로그램이 안정적으로 동작하도록 보장하는 것입니다. 예외는 다양한 원인으로 발생할 수 있으며, 예외가 발생한 경우 해당 예외를 처리하지 않으면 프로그램이 강제 종료되거나, 원치 않는 결과가 발생할 수 있습니다.

Java에서는 예외 처리를 위해 try-catch 블록을 사용합니다. try 블록은 예외가 발생할 수 있는 코드를 포함하고, catch 블록은 try 블록에서 발생한 예외를 처리하는 코드를 포함합니다. 예외가 발생하면 해당 예외에 대한 catch 블록이 실행되며, 프로그램은 정상적으로 계속 실행됩니다.
```

# Java에서 메모리 관리 방식과 Garbage Collection에 대해 설명해주세요.
```
Java는 가비지 컬렉션(Garbage Collection)을 사용하여 메모리 관리를 합니다. 이는 프로그래머가 수동으로 메모리를 할당하고 해제하는 작업을 하지 않아도 된다는 장점이 있습니다.

Java에서 메모리는 두 가지 영역으로 나누어져 있습니다. 하나는 스택(stack)이고 다른 하나는 힙(heap)입니다. 스택은 지역 변수, 메서드 호출 등에 사용되며, 힙은 객체와 배열 등을 저장하는 데 사용됩니다. 메모리는 JVM(Java Virtual Machine)에서 관리되며, JVM은 가비지 컬렉션을 통해 사용되지 않는 객체를 자동으로 제거하여 메모리를 회수합니다.

Java의 가비지 컬렉션은 메모리를 관리하는 알고리즘에 따라 다양한 방식으로 동작합니다. 대표적인 알고리즘으로는 Mark-and-Sweep, Reference Counting, Generational 등이 있습니다.

Mark-and-Sweep 알고리즘은 힙에서 사용하지 않는 객체를 탐색하고, 해당 객체를 참조하는 모든 포인터를 삭제한 뒤, 메모리를 해제합니다. Reference Counting 알고리즘은 객체를 참조하는 포인터의 개수를 세어, 참조하는 포인터가 없을 때 해당 객체를 제거합니다. Generational 알고리즘은 객체를 새로 생성하면 새로운 영역에 할당하고, 일정 시간이 지나면 해당 영역의 객체를 일괄 제거합니다.

Java에서 가비지 컬렉션은 시스템 자원을 사용하므로, 메모리 사용량과 성능 간의 균형을 유지하는 것이 중요합니다. 따라서, 메모리 사용 패턴과 애플리케이션의 특성에 따라 적절한 가비지 컬렉션 방식을 선택하고, 가비지 컬렉션 튜닝을 통해 최적화하는 것이 필요합니다.
```

# Java에서 다형성이란 무엇이며, 어떻게 구현할 수 있나요?
```
Java에서 다형성(Polymorphism)은 객체지향 프로그래밍의 중요한 개념 중 하나입니다. 다형성은 하나의 객체가 여러 가지 타입을 가질 수 있고, 하나의 타입으로부터 여러 가지 객체를 생성할 수 있다는 것을 의미합니다. 이것은 코드의 재사용성과 유연성을 높여줍니다.

Java에서 다형성을 구현하는 방법은 두 가지가 있습니다.

메소드 오버라이딩(Overriding)
부모 클래스에서 정의된 메소드를 자식 클래스에서 다시 정의하는 것입니다.
자식 클래스에서 부모 클래스에 정의된 메소드와 같은 시그니처를 가진 메소드를 정의하면, 자식 클래스의 메소드가 호출됩니다.
이를 통해 자식 클래스는 부모 클래스의 인터페이스를 구현하면서 자신만의 구현을 추가할 수 있습니다.
다형성을 이용한 객체 생성
부모 클래스 타입 변수를 선언하고 자식 클래스의 객체를 생성할 수 있습니다.
이렇게 생성된 객체는 부모 클래스 타입으로 참조되므로, 부모 클래스에 정의된 메소드만 호출할 수 있습니다.
하지만 실제로 참조하는 객체가 자식 클래스 객체일 경우, 자식 클래스에서 오버라이딩한 메소드가 호출됩니다.
```

# Java에서 쓰레드와 동기화에 대해 설명해주세요.
```
Java에서 쓰레드(Thread)는 동시에 여러 가지 작업을 처리할 수 있도록 하는 기능입니다. 하나의 프로세스 내에서 실행되며, 각각의 쓰레드는 독립적인 실행 흐름을 가지고 있습니다. 

Java에서 쓰레드를 구현하는 방법은 두 가지가 있습니다.

1. Thread 클래스를 상속받아 구현하는 방법
- Thread 클래스를 상속받아 run() 메소드를 구현하고 start() 메소드를 호출하여 실행합니다.

2. Runnable 인터페이스를 구현하는 방법
- Runnable 인터페이스를 구현한 클래스의 객체를 생성하고, 이를 Thread 클래스의 생성자로 전달하여 실행합니다.

Java에서 동기화(Synchronization)는 여러 쓰레드가 공유하는 자원에 대한 접근을 제어하는 기능입니다. 동기화를 사용하지 않으면 여러 쓰레드가 동시에 자원에 접근하여 원하지 않는 결과를 초래할 수 있습니다.

Java에서 동기화를 구현하는 방법은 두 가지가 있습니다.

1. synchronized 키워드를 사용하는 방법
- synchronized 키워드를 사용하여 특정 블록이나 메소드에 대한 접근을 한 번에 하나의 쓰레드만 가능하도록 제한합니다.

2. Lock 인터페이스를 사용하는 방법
- Lock 인터페이스를 구현한 클래스를 사용하여 동기화를 구현합니다.
- ReentrantLock 클래스는 가장 많이 사용되는 Lock 인터페이스 구현체 중 하나입니다.

동기화를 사용하여 여러 쓰레드가 공유하는 자원에 대한 접근을 제어하면서, 쓰레드 간의 경쟁 상황(Race Condition)이 발생하지 않도록 합니다. 이를 통해 안정적인 멀티쓰레드 환경을 구현할 수 있습니다.
```
# Java에서 컬렉션 프레임워크에 대해 설명해주세요.
```
Java에서 컬렉션 프레임워크(Collection Framework)는 데이터 그룹을 저장, 조작, 검색하기 위한 클래스와 인터페이스를 제공합니다. 이러한 클래스와 인터페이스를 사용하여 데이터 그룹을 쉽게 조작하고 처리할 수 있습니다.

컬렉션 프레임워크는 다음과 같은 특징을 가지고 있습니다.

1. 인터페이스와 구현 클래스의 분리
- 인터페이스와 구현 클래스가 분리되어 있기 때문에, 사용자는 인터페이스를 사용하여 구현 클래스의 구현 내용을 알 필요가 없습니다.
자동으로 크기 조절 가능
크기를 조절하는 메소드를 제공하여, 데이터 그룹의 크기를 자동으로 조절할 수 있습니다.
2. 제네릭스(Generic) 지원
- 제네릭스를 사용하여 컬렉션에 저장되는 데이터 타입을 명시할 수 있습니다. 이를 통해 안정적인 프로그래밍이 가능해집니다.


Java에서 제공하는 주요 컬렉션 클래스는 다음과 같습니다.

1. List
- 순서가 있는 데이터 그룹을 저장합니다.
- 중복된 데이터를 허용합니다.
- ArrayList, LinkedList, Vector 등이 있습니다.

2. Set
- 순서가 없는 데이터 그룹을 저장합니다.
- 중복된 데이터를 허용하지 않습니다.
- HashSet, TreeSet 등이 있습니다.

3. Map
- Key와 Value의 쌍으로 이루어진 데이터를 저장합니다.
- Key는 중복될 수 없습니다.
- HashMap, TreeMap 등이 있습니다.

컬렉션 프레임워크는 Java에서 데이터 그룹을 다루는 가장 중요한 기능 중 하나입니다. 이를 활용하여 데이터 처리와 관리를 효율적으로 할 수 있습니다.
```

# Java에서 문자열(String)과 StringBuilder/StringBuffer의 차이는 무엇인가요?
```
Java에서 문자열(String)은 불변(immutable)한 객체입니다. 즉, 한 번 생성된 문자열 객체의 값은 변경할 수 없습니다. 이러한 특성 때문에 문자열을 변경하는 작업이 필요한 경우에는 매번 새로운 문자열 객체가 생성되어 메모리를 소비하게 됩니다.

반면에 StringBuilder와 StringBuffer는 가변(mutable)한 객체입니다. 이들은 문자열을 동적으로 생성하고 변경할 수 있습니다. StringBuilder와 StringBuffer는 내부적으로 가변 크기의 char 배열을 유지하며, 문자열을 추가하거나 변경할 때 배열의 크기를 조절하여 문자열을 저장합니다. 이러한 특성 때문에 StringBuilder와 StringBuffer는 문자열을 변경하는 작업이 필요한 경우에 유용하게 사용됩니다.

StringBuilder와 StringBuffer의 차이점은 동기화(synchronization) 여부입니다. StringBuffer는 동기화된 메소드로 구현되어 있기 때문에 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 StringBuilder는 동기화되지 않은 메소드로 구현되어 있기 때문에 멀티스레드 환경에서 사용할 때는 주의가 필요합니다.

따라서, 문자열을 변경하는 작업이 필요한 경우에는 StringBuilder나 StringBuffer를 사용하고, 문자열을 변경할 필요가 없는 경우에는 String을 사용하는 것이 좋습니다.
```

# Java에서 static 키워드가 무엇을 의미하며, 어떻게 사용될까요?
```
Java에서 static은 클래스 레벨의 키워드로 사용됩니다. 이는 다음과 같은 의미를 갖습니다.

1. static 변수
static 변수는 클래스 레벨에서 정의되는 변수로, 객체 생성과 상관없이 클래스가 로딩될 때 초기화됩니다. 모든 객체가 이 변수를 공유하며, 변경될 경우 모든 객체에서 동일한 값이 유지됩니다.

2. static 메소드
static 메소드는 클래스 레벨에서 정의되는 메소드로, 객체 생성과 상관없이 호출될 수 있습니다. static 메소드 내부에서는 인스턴스 변수에 접근할 수 없으며, 오직 static 변수나 메소드에만 접근이 가능합니다. 주로 유틸리티 메소드나 팩토리 메소드 등을 구현할 때 사용됩니다.

3. static 블록
static 블록은 클래스 로딩시에 실행되는 코드 블록입니다. 주로 클래스 초기화에 필요한 작업을 수행할 때 사용됩니다.

static 키워드는 다음과 같은 장점을 갖습니다.

- 객체 생성 없이 클래스 레벨에서 접근 가능하므로, 메모리 사용을 최적화할 수 있습니다.
- 상수나 유틸리티 메소드 등을 구현할 때 유용합니다.
- 객체 지향 프로그래밍에서는 객체 간 상호작용을 통해 데이터를 처리하는 것이 일반적입니다. 그러나 static 변수나 메소드는 클래스 레벨에서 공유되므로, 다른 객체 간에 데이터를 공유해야 할 때 사용할 수 있습니다.

하지만 static 키워드의 남발은 객체 지향적인 설계를 방해할 수 있으므로, 적절한 사용이 필요합니다. 특히, static 변수를 사용할 때는 공유 데이터에 대한 동기화 문제가 발생할 수 있으므로, 주의가 필요합니다.
```

# Java에서 다중 상속이 불가능한 이유는 무엇인가요?
```
Java에서 다중 상속이 불가능한 이유는 여러 가지가 있지만, 가장 큰 이유 중 하나는 다이아몬드 상속 문제입니다.

예를 들어, 클래스 A와 B가 클래스 C를 상속하고, 클래스 D가 A와 B를 상속하는 경우, 클래스 D는 A와 B 모두에서 C 클래스를 상속받게 됩니다. 이 경우, D 클래스에서 C 클래스의 어떤 메소드를 호출해야 하는지 모호해지며, 이러한 모호성 때문에 다이아몬드 상속 문제가 발생할 수 있습니다.

이를 해결하기 위해서 Java에서는 클래스 다중 상속 대신 인터페이스를 이용한 다중 상속을 지원하고 있습니다. 인터페이스는 다중 상속이 가능하며, 다이아몬드 상속 문제도 발생하지 않습니다. 인터페이스는 구현해야 하는 메소드를 강제하기 때문에 클래스 간의 상속 관계에서 발생할 수 있는 문제를 방지할 수 있습니다.
```

# Java8의 특징?
```
1. 람다 표현식
함수형 프로그래밍을 지원하기 위해 람다 표현식이 추가되었습니다. 이를 통해 코드의 간결성과 가독성이 증가하였습니다.
람다 표현식은 익명 함수를 정의하는 것으로, 메서드의 매개변수로 전달하거나 변수에 할당할 수 있습니다.

2. 스트림 API
스트림 API는 람다 표현식과 함께 제공되어 컬렉션 데이터를 처리하는 방법을 개선하였습니다. 스트림 API를 사용하면 병렬 처리가 가능해져서 대용량 데이터 처리가 더욱 효율적으로 이루어집니다.

3. 메서드 참조
람다 표현식에서 사용되는 메서드 참조는 람다 표현식을 더욱 간결하게 만들어줍니다.

4. 인터페이스의 디폴트 메서드
인터페이스에 디폴트 메서드를 추가하여 기존 코드의 호환성을 유지하면서 새로운 기능을 추가할 수 있습니다.

5. Optional 클래스
Optional 클래스는 null을 다루는 방법을 개선하였습니다. Optional 클래스를 사용하면 null 처리를 명시적으로 표현하여 코드의 가독성을 높일 수 있습니다.
Optional 클래스는 null을 반환하는 메서드에서 NullPointerException을 방지하기 위해 도입되었습니다. 이를 통해 안전하게 null 처리를 할 수 있습니다.

6. Date/Time API
자바 8에서는 새로운 Date/Time API가 도입되었습니다. 이는 이전의 Date/Time API와 달리 불변 객체로 설계되어 있으며, 시간 계산과 관련된 다양한 기능을 제공합니다.

7. Nashorn JavaScript 엔진
Nashorn은 자바스크립트의 빠른 실행 속도와 자바 플랫폼의 강력한 기능을 함께 사용할 수 있도록 자바스크립트 엔진을 제공합니다. 이를 통해 자바와 자바스크립트 간의 상호 운용성이 향상되었습니다.

8. PermGen 공간의 제거
Java 8에서는 PermGen 공간이 제거되었습니다. PermGen 공간은 클래스 메타데이터를 저장하는 공간으로, Java 7 이전에는 PermGen 공간이 가득 차면 OutOfMemoryError가 발생하였습니다. Java 8에서는 PermGen 공간이 제거되고, 클래스 메타데이터는 Metaspace 영역에 저장됩니다. Metaspace 영역은 PermGen 공간과 달리 힙 영역에 할당되며, 필요한 만큼 메모리를 동적으로 할당하여 사용합니다.
```

# Java 예외의 구조
```
Java에서 예외는 Throwable 클래스를 상속하는 Exception 및 Error 클래스를 기반으로 합니다.

Exception : 일반적인 예외 상황을 나타냅니다. 프로그램에서 예측 가능하며 처리가 가능한 예외입니다. RuntimeException 및 그 하위 클래스와, IOException, SQLException 등이 이에 속합니다.
Error : 시스템 레벨의 예외 상황을 나타냅니다. 시스템에서 처리할 수 없는 예외로, 프로그램에서 이러한 예외를 처리하는 것은 권장되지 않습니다. OutOfMemoryError, StackOverflowError 등이 이에 속합니다.
Exception과 그 하위 클래스는 반드시 처리해야 하는 체크 예외와, 처리하지 않아도 되는 언체크 예외로 나뉘어집니다.

체크 예외 : IOException, SQLException 등처럼 반드시 예외 처리를 해주어야 하는 예외입니다. 메소드를 호출할 때 반드시 예외 처리 코드를 작성해야 합니다.
언체크 예외 : RuntimeException, NullPointerException 등처럼 예외 처리 코드를 작성하지 않아도 되는 예외입니다.
```


# Java 가비지 컬렉션 튜닝 방법 ?
```
1. 메모리 할당과 해제를 최소화합니다.
객체 생성과 해제를 빈번하게 하면 가비지 컬렉션이 자주 발생하므로 성능 저하의 원인이 됩니다. 따라서, 객체를 재사용하고, 불필요한 객체는 적절히 해제하여 메모리 사용을 최적화합니다.

2. 적절한 가비지 컬렉션 방식을 선택합니다.
가비지 컬렉션 방식은 메모리 사용 패턴과 애플리케이션의 특성에 따라 다르게 선택해야 합니다. 예를 들어, 메모리 사용이 일정하게 발생하는 경우에는 Mark-and-Sweep 알고리즘이 적합하고, 객체가 빠르게 생성되고 삭제되는 경우에는 Generational 알고리즘이 적합합니다.

3. 메모리 크기를 조정합니다.
애플리케이션에서 사용하는 메모리 크기는 JVM의 Xmx 옵션으로 조정할 수 있습니다. 메모리 크기를 충분히 크게 설정하면 가비지 컬렉션이 발생하는 빈도를 줄일 수 있습니다. 그러나 메모리를 너무 많이 할당하면 시스템의 다른 프로세스에서 사용하는 메모리를 차지할 수 있으므로, 적절한 메모리 크기를 선택해야 합니다.

4. 가비지 컬렉션 로그를 분석합니다.
JVM에서는 가비지 컬렉션 로그를 제공하므로, 이를 분석하여 가비지 컬렉션에 걸리는 시간, 힙 메모리 사용량 등을 확인할 수 있습니다. 로그를 분석하여 가비지 컬렉션 횟수를 최소화하고, 가비지 컬렉션으로 인한 성능 저하를 최소화할 수 있습니다.

5. GC 튜닝 옵션을 설정합니다.
JVM은 다양한 GC 튜닝 옵션을 제공합니다. 이를 설정하여 가비지 컬렉션의 동작 방식을 조정할 수 있습니다. 예를 들어, Young Generation의 크기를 늘리거나, Old Generation의 크기를 조정할 수 있습니다.
```
